// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var worldMapRoot = WorldMapRoot.FromJson(jsonString);

using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Forms;
using QuickType;

namespace ROAMapper
{

    class WorldMap
    {
        static WorldMapRoot worldMap;
        public static List<MapTile> MapTiles;

        public static void LoadMap()
        {
            string fileName = "modified_world.json";
            string jsonData = System.IO.File.ReadAllText(fileName);

            try
            {
                worldMap = WorldMapRoot.FromJson(jsonData);
            }
            catch (Exception e)
            {
                Console.WriteLine("Error Loading World JSON");
                Console.WriteLine(e);
            }

            MapTiles = new List<MapTile>();

            // Register events
            PacketHandlerEvents.ROAInfoUpdateEvent += onROAInfoUpdate;

            Console.WriteLine("World Map Loaded");
        }


        // Loads the tile at mapID and all its neighbor tiles, adding them to the static WorldMap.MapTiles
        private static void LoadMapTilesFromSeed(string mapID)
        {
            MapTile tile = new MapTile(mapID);
            // Precent infinte tile loading
            if (TileHasBeenLoaded(tile.mapID))
                return;

            MapTiles.Add(tile);

            foreach (KeyValuePair<string, string> exit in tile.Exits)
            {
                LoadMapTilesFromSeed(exit.Value);
            }
        }

        private static void onROAInfoUpdate(object sender, ROAInfoEventArgs e)
        {
            // POST the ROA updates

            string url = Settings.ROA_MAPPER_API + "map/roa" + "?v=" + Settings.clientVersion;

            var client = new WebClient();
            client.Headers[HttpRequestHeader.ContentType] = "application/json";
            Uri uri = new Uri(url);
            var servicePoint = ServicePointManager.FindServicePoint(uri);
            servicePoint.Expect100Continue = false;

            client.UploadStringAsync(uri, Newtonsoft.Json.JsonConvert.SerializeObject(e));
        }

        public static string GetMapDisplayName(string mapID)
        {
            try
            {
                return GetClusterByID(mapID).Displayname;
            }
            catch
            {
                return "Unknown";
            }
        }

        public static Dictionary<string, string> GetMapExits(string mapID)
        {
            Dictionary<string, string> exits = new Dictionary<string, string>();
            Cluster cluster = null;

            cluster = GetClusterByID(mapID);
            if (cluster == null)
                return null;

            // Console.WriteLine("Getting Exits For: " + cluster.Displayname + "(" + mapID + ")");

            int counter = 1;

            foreach (Exit exit in cluster.Exits.Exit)
            {
                // exitID example: a2d07113-7f83-44c7-a3b1-f4916a4cfabf@4356
                // Only care about last chunk

                string exitID = exit.Targetid.Split('@')[1];

                Cluster exitCluster = null;
                exitCluster = GetClusterByID(exitID);
                if (exitCluster == null)
                    continue;

                // Console.WriteLine("Getting Direction For "+ GetMapDisplayName(exitID) + "(" + exitID + ")  From " + GetMapDisplayName(cluster.Id));
                string exitDirection = GetDirectionFromPosString(exit.Pos);
                if (exitDirection == null)
                    continue;

                // Handle multiple exits in same direction
                if (exits.ContainsKey(exitDirection))
                {
                    exitDirection += "_" + counter;
                    counter++;
                }

                exits.Add(exitDirection, exit.Targetid);

            }
            return exits;
        }


        // Takes a target exitID and returns the cardinal direction of the exit in the target's map. Used for drawing path lines.
        public static string GetExitCardinalLocation(string targetID)
        {
            string direction = "";
            string exitMapID = targetID.Split('@')[1];
            string exitID = targetID.Split('@')[0];

            // Console.WriteLine("Getting Direction For: " + exitID);

            Cluster cluster = GetClusterByID(exitMapID);

            foreach (Exit e in cluster.Exits.Exit)
            {
                if (e.Id.ToString() == exitID)
                {
                    return GetDirectionFromPosString(e.Pos);
                }
            }


            return direction;
        }

        // Get a MapTile from a world coordinate. Used for when clicking the map
        public static MapTile GetMapTileFromWorldCoordinate(Point pos)
        {
            foreach (MapTile tile in MapTiles)
            {
                if (tile.worldPosition.X == pos.X && tile.worldPosition.Y == pos.Y)
                {
                    return tile;
                }
            }
            return null;
        }

        // Get a cardinal direction from a pos string
        private static string GetDirectionFromPosString(string pos)
        {
            //Example Pos String: "@pos": "-360.5 -0.5"

            string[] coordinates = pos.Split(' ');
            float x = float.Parse(coordinates[0]);
            float y = float.Parse(coordinates[1]);

            if (Math.Abs(x) >= Math.Abs(y) && x < 0)
                return "NW";
            if (Math.Abs(y) >= Math.Abs(x) && y < 0)
                return "SW";
            if (Math.Abs(x) >= Math.Abs(y) && x > 0)
                return "SE";
            if (Math.Abs(y) >= Math.Abs(x) && y > 0)
                return "NE";

            Console.WriteLine("Failed To Find Direction: " + pos);
            return null;
        }

        public static Cluster GetClusterByID(string mapID)
        {
            foreach (Cluster cluster in worldMap.World.Clusters.Cluster)
            {
                if (cluster.Id == mapID)
                    return cluster;
            }
            return null;
        }

        public static bool TileHasBeenLoaded(string mapID)
        {
            foreach (MapTile tile in MapTiles)
            {
                if (tile.mapID == mapID)
                    return true;
            }
            return false;
        }

        public static bool IsValidMapTile(string mapID)
        {
            // If an exit TargetID was used, grab the mapID portion
            if (mapID.Contains("@"))
            {
                mapID = mapID.Split('@')[1];
            }

            foreach (MapTile tile in MapTiles)
            {
                if (tile.mapID == mapID)
                    return true;
            }
            return false;
        }

    }
}


namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class WorldMapRoot
    {
        [JsonProperty("?xml")]
        public Xml Xml { get; set; }

        [JsonProperty("world")]
        public World World { get; set; }
    }

    public partial class World
    {
        [JsonProperty("@boundsmax")]
        public string Boundsmax { get; set; }

        [JsonProperty("@boundsmin")]
        public string Boundsmin { get; set; }

        [JsonProperty("@scale")]
        public string Scale { get; set; }

        [JsonProperty("@version")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Version { get; set; }

        [JsonProperty("@viewportpos")]
        public string Viewportpos { get; set; }

        [JsonProperty("@viewportzoom")]
        public string Viewportzoom { get; set; }

        [JsonProperty("clusters")]
        public Clusters Clusters { get; set; }
    }

    public partial class Clusters
    {
        [JsonProperty("cluster")]
        public Cluster[] Cluster { get; set; }
    }

    public partial class Cluster
    {
        [JsonProperty("@categoryname")]
        public string Categoryname { get; set; }

        [JsonProperty("@displayname")]
        public string Displayname { get; set; }

        [JsonProperty("@editoroffset")]
        public string Editoroffset { get; set; }

        [JsonProperty("@enabled")]
        [JsonConverter(typeof(FluffyParseStringConverter))]
        public bool Enabled { get; set; }

        [JsonProperty("@file")]
        public string File { get; set; }

        [JsonProperty("@id")]
        public string Id { get; set; }

        [JsonProperty("@minimapBoundsMax")]
        public string MinimapBoundsMax { get; set; }

        [JsonProperty("@minimapBoundsMin")]
        public string MinimapBoundsMin { get; set; }

        [JsonProperty("@origin")]
        public string Origin { get; set; }

        [JsonProperty("@rareresourcedistribution")]
        public Rareresourcedistribution Rareresourcedistribution { get; set; }

        [JsonProperty("@size")]
        public string Size { get; set; }

        [JsonProperty("@speciallocation")]
        public string Speciallocation { get; set; }

        [JsonProperty("@timeregion")]
        public Timeregion Timeregion { get; set; }

        [JsonProperty("@type")]
        public string Type { get; set; }

        [JsonProperty("distribution")]
        public Distribution Distribution { get; set; }

        [JsonProperty("exits")]
        public Exits Exits { get; set; }

        [JsonProperty("islandaccesspoints", NullValueHandling = NullValueHandling.Ignore)]
        public Islandaccesspoints Islandaccesspoints { get; set; }

        [JsonProperty("minimapmarkers", NullValueHandling = NullValueHandling.Ignore)]
        public Mapmarkers Minimapmarkers { get; set; }

        [JsonProperty("mobcounts")]
        public Mobcounts Mobcounts { get; set; }

        [JsonProperty("outposts", NullValueHandling = NullValueHandling.Ignore)]
        public Outposts Outposts { get; set; }

        [JsonProperty("portalentrances", NullValueHandling = NullValueHandling.Ignore)]
        public Portalentrances Portalentrances { get; set; }

        [JsonProperty("questgiverobjects")]
        public Questgiverobjects Questgiverobjects { get; set; }

        [JsonProperty("questgivers", NullValueHandling = NullValueHandling.Ignore)]
        public Questgivers Questgivers { get; set; }

        [JsonProperty("territories", NullValueHandling = NullValueHandling.Ignore)]
        public Territories Territories { get; set; }

        [JsonProperty("travelpoints", NullValueHandling = NullValueHandling.Ignore)]
        public Travelpoints Travelpoints { get; set; }

        [JsonProperty("worldbosses", NullValueHandling = NullValueHandling.Ignore)]
        public Worldbosses Worldbosses { get; set; }

        [JsonProperty("@minimapBaseLevel", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long? MinimapBaseLevel { get; set; }

        [JsonProperty("@minimapHeightRange", NullValueHandling = NullValueHandling.Ignore)]
        public MinimapHeightRange? MinimapHeightRange { get; set; }

        [JsonProperty("@worldmapposition", NullValueHandling = NullValueHandling.Ignore)]
        public string Worldmapposition { get; set; }

        [JsonProperty("hellgatemobspawnpoints", NullValueHandling = NullValueHandling.Ignore)]
        public Hellgatemobspawnpoints Hellgatemobspawnpoints { get; set; }

        [JsonProperty("roads", NullValueHandling = NullValueHandling.Ignore)]
        public Roads Roads { get; set; }

        [JsonProperty("worldmapmarkers", NullValueHandling = NullValueHandling.Ignore)]
        public Mapmarkers Worldmapmarkers { get; set; }

        [JsonProperty("startpoints", NullValueHandling = NullValueHandling.Ignore)]
        public Startpoints Startpoints { get; set; }

        [JsonProperty("treasurechests", NullValueHandling = NullValueHandling.Ignore)]
        public Treasurechests Treasurechests { get; set; }

        [JsonProperty("hellgateexits", NullValueHandling = NullValueHandling.Ignore)]
        public Hellgateexits Hellgateexits { get; set; }

        [JsonProperty("@marketplacegroup", NullValueHandling = NullValueHandling.Ignore)]
        public string Marketplacegroup { get; set; }

        [JsonProperty("portalexits", NullValueHandling = NullValueHandling.Ignore)]
        public Portalexits Portalexits { get; set; }
    }

    public partial class Distribution
    {
        [JsonProperty("@realestates")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Realestates { get; set; }

        [JsonProperty("resource", NullValueHandling = NullValueHandling.Ignore)]
        public Resource[] Resource { get; set; }
    }

    public partial class Resource
    {
        [JsonProperty("@count")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Count { get; set; }

        [JsonProperty("@name")]
        public Name Name { get; set; }

        [JsonProperty("@tier")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Tier { get; set; }
    }

    public partial class Exits
    {
        [JsonProperty("exit")]
        public Exit[] Exit { get; set; }
    }

    public partial class Exit
    {
        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@pos")]
        public string Pos { get; set; }

        [JsonProperty("@restricted")]
        [JsonConverter(typeof(FluffyParseStringConverter))]
        public bool Restricted { get; set; }

        [JsonProperty("@roadtype")]
        public Roadtype Roadtype { get; set; }

        [JsonProperty("@targetid")]
        public string Targetid { get; set; }

        [JsonProperty("@targettype")]
        public Targettype Targettype { get; set; }

        [JsonProperty("@territory")]
        public Guid Territory { get; set; }
    }

    public partial class Hellgateexits
    {
        [JsonProperty("hellgateexit")]
        public Hellgate[] Hellgateexit { get; set; }
    }

    public partial class Hellgate
    {
        [JsonProperty("@id")]
        public string Id { get; set; }

        [JsonProperty("@pos")]
        public string Pos { get; set; }
    }

    public partial class Hellgatemobspawnpoints
    {
        [JsonProperty("hellgatemobspawnpoint")]
        public Hellgate Hellgatemobspawnpoint { get; set; }
    }

    public partial class Islandaccesspoints
    {
        [JsonProperty("islandaccesspoint")]
        public Islandaccesspoint Islandaccesspoint { get; set; }
    }

    public partial class Islandaccesspoint
    {
        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@travelpointid")]
        public Guid Travelpointid { get; set; }
    }

    public partial class Mapmarkers
    {
        [JsonProperty("marker")]
        public MarkerUnion Marker { get; set; }
    }

    public partial class MarkerElement
    {
        [JsonProperty("@pos")]
        public string Pos { get; set; }

        [JsonProperty("@type")]
        public string Type { get; set; }
    }

    public partial class Mobcounts
    {
        [JsonProperty("mob")]
        public Mob[] Mob { get; set; }
    }

    public partial class Mob
    {
        [JsonProperty("@count")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Count { get; set; }

        [JsonProperty("@name")]
        public string Name { get; set; }
    }

    public partial class Outposts
    {
        [JsonProperty("outpost")]
        public OutpostUnion Outpost { get; set; }
    }

    public partial class OutpostElement
    {
        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@pos")]
        public string Pos { get; set; }

        [JsonProperty("@type")]
        public OutpostType Type { get; set; }
    }

    public partial class Portalentrances
    {
        [JsonProperty("portalentrance")]
        public Portale Portalentrance { get; set; }
    }

    public partial class Portale
    {
        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@kind")]
        public string Kind { get; set; }

        [JsonProperty("@pos")]
        public string Pos { get; set; }

        [JsonProperty("@targetid", NullValueHandling = NullValueHandling.Ignore)]
        public string Targetid { get; set; }
    }

    public partial class Portalexits
    {
        [JsonProperty("portalexit")]
        public Portale Portalexit { get; set; }
    }

    public partial class Questgiverobjects
    {
        [JsonProperty("questgiverobject")]
        public QuestgiverobjectUnion Questgiverobject { get; set; }
    }

    public partial class QuestgiverobjectElement
    {
        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@type")]
        public string Type { get; set; }
    }

    public partial class Questgivers
    {
        [JsonProperty("questgiver")]
        public QuestgiverUnion Questgiver { get; set; }
    }

    public partial class QuestgiverElement
    {
        [JsonProperty("@firstname")]
        public string Firstname { get; set; }

        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@pos")]
        public string Pos { get; set; }

        [JsonProperty("@surname")]
        public string Surname { get; set; }

        [JsonProperty("@type")]
        public string Type { get; set; }
    }

    public partial class Roads
    {
        [JsonProperty("@links")]
        public string Links { get; set; }

        [JsonProperty("@nodes")]
        public string Nodes { get; set; }
    }

    public partial class Startpoints
    {
        [JsonProperty("startpoint")]
        public Startpoint Startpoint { get; set; }
    }

    public partial class Startpoint
    {
        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@pos")]
        public string Pos { get; set; }

        [JsonProperty("@roty")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Roty { get; set; }
    }

    public partial class Territories
    {
        [JsonProperty("territory")]
        public TerritoryUnion Territory { get; set; }
    }

    public partial class TerritoryElement
    {
        [JsonProperty("@center")]
        public string Center { get; set; }

        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@monolith")]
        public string Monolith { get; set; }

        [JsonProperty("@name")]
        public string Name { get; set; }

        [JsonProperty("@resourcetype", NullValueHandling = NullValueHandling.Ignore)]
        public Resourcetype? Resourcetype { get; set; }

        [JsonProperty("@size", NullValueHandling = NullValueHandling.Ignore)]
        public Size? Size { get; set; }

        [JsonProperty("@territorytype")]
        public Territorytype Territorytype { get; set; }

        [JsonProperty("connections")]
        public PurpleConnections Connections { get; set; }

        [JsonProperty("@castletype", NullValueHandling = NullValueHandling.Ignore)]
        public Castletype? Castletype { get; set; }
    }

    public partial class PurpleConnections
    {
        [JsonProperty("connection")]
        public PurpleConnection Connection { get; set; }
    }

    public partial class PurpleConnection
    {
        [JsonProperty("@to")]
        public string To { get; set; }

        [JsonProperty("@type")]
        public ConnectionType Type { get; set; }
    }

    public partial class PurpleTerritory
    {
        [JsonProperty("@center")]
        public string Center { get; set; }

        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@monolith")]
        public string Monolith { get; set; }

        [JsonProperty("@name")]
        public string Name { get; set; }

        [JsonProperty("@resourcetype", NullValueHandling = NullValueHandling.Ignore)]
        public Resourcetype? Resourcetype { get; set; }

        [JsonProperty("@size", NullValueHandling = NullValueHandling.Ignore)]
        public Size? Size { get; set; }

        [JsonProperty("@territorytype")]
        public Territorytype Territorytype { get; set; }

        [JsonProperty("connections")]
        public FluffyConnections Connections { get; set; }

        [JsonProperty("@castletype", NullValueHandling = NullValueHandling.Ignore)]
        public Castletype? Castletype { get; set; }
    }

    public partial class FluffyConnections
    {
        [JsonProperty("connection")]
        public PurpleConnection[] Connection { get; set; }
    }

    public partial class Travelpoints
    {
        [JsonProperty("travelpoint")]
        public TravelpointUnion Travelpoint { get; set; }
    }

    public partial class TravelpointElement
    {
        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@pos")]
        public string Pos { get; set; }

        [JsonProperty("connections")]
        public TentacledConnections Connections { get; set; }
    }

    public partial class TentacledConnections
    {
        [JsonProperty("connection")]
        public ConnectionUnion Connection { get; set; }
    }

    public partial class ConnectionConnection
    {
        [JsonProperty("@costmodifier")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Costmodifier { get; set; }

        [JsonProperty("@noluggage")]
        [JsonConverter(typeof(FluffyParseStringConverter))]
        public bool Noluggage { get; set; }

        [JsonProperty("@to")]
        public string To { get; set; }
    }

    public partial class PurpleTravelpoint
    {
        [JsonProperty("@id")]
        public Guid Id { get; set; }

        [JsonProperty("@pos")]
        public string Pos { get; set; }

        [JsonProperty("connections")]
        public StickyConnections Connections { get; set; }
    }

    public partial class StickyConnections
    {
        [JsonProperty("connection")]
        public ConnectionConnection[] Connection { get; set; }
    }

    public partial class Treasurechests
    {
        [JsonProperty("treasurechest")]
        public OutpostUnion Treasurechest { get; set; }
    }

    public partial class Worldbosses
    {
        [JsonProperty("worldboss")]
        public MarkerUnion Worldboss { get; set; }
    }

    public partial class Xml
    {
        [JsonProperty("@encoding")]
        public string Encoding { get; set; }

        [JsonProperty("@standalone")]
        public string Standalone { get; set; }

        [JsonProperty("@version")]
        public string Version { get; set; }
    }

    public enum Name { Fiber, Hide, Ore, Rock, Wood };

    public enum Roadtype { Primary, Secondary };

    public enum Targettype { Cluster, DungeonGroup, DungeonRaid, DungeonSandbox, DungeonSolo, DungeonSpecial, DungeonStubSolo };

    public enum MinimapHeightRange { The012, The016, The020, The028, The128, The160, The1616, The3620, The812, The824, The836, The88 };

    public enum OutpostType { OutlandChest, OutlandCofferCastle, OutlandCofferCastleoutpost, OutlandLocker, OutpostForest, OutpostHighland, OutpostMountain, OutpostSteppe, OutpostSwamp, RoyalLockerT5, RoyalLockerT7 };

    public enum Rareresourcedistribution { Default, OutQ1, OutQ2, OutQ3, OutQ4, OutQ5, OutQ6, Red, Red2, Safe, Yellow };

    public enum Castletype { Mediumcastle, Smallcastle };

    public enum ConnectionType { East, North, South, West };

    public enum Resourcetype { Farm, Resource };

    public enum Size { The148148, The150150, The260260 };

    public enum Territorytype { Castle, Siegecamp, Watchtower };

    public enum Timeregion { AmericaEast, Br00_00, Eu, Eu20_00, Eu21_00, EuRu18_00, Ru15_00, Ru16_00, RuAsia12_00, Us01_00, Us03_00, Us04_00, Us05_00 };

    public partial struct MarkerUnion
    {
        public MarkerElement MarkerElement;
        public MarkerElement[] MarkerElementArray;

        public static implicit operator MarkerUnion(MarkerElement MarkerElement) => new MarkerUnion { MarkerElement = MarkerElement };
        public static implicit operator MarkerUnion(MarkerElement[] MarkerElementArray) => new MarkerUnion { MarkerElementArray = MarkerElementArray };
    }

    public partial struct OutpostUnion
    {
        public OutpostElement OutpostElement;
        public OutpostElement[] OutpostElementArray;

        public static implicit operator OutpostUnion(OutpostElement OutpostElement) => new OutpostUnion { OutpostElement = OutpostElement };
        public static implicit operator OutpostUnion(OutpostElement[] OutpostElementArray) => new OutpostUnion { OutpostElementArray = OutpostElementArray };
    }

    public partial struct QuestgiverobjectUnion
    {
        public QuestgiverobjectElement QuestgiverobjectElement;
        public QuestgiverobjectElement[] QuestgiverobjectElementArray;

        public static implicit operator QuestgiverobjectUnion(QuestgiverobjectElement QuestgiverobjectElement) => new QuestgiverobjectUnion { QuestgiverobjectElement = QuestgiverobjectElement };
        public static implicit operator QuestgiverobjectUnion(QuestgiverobjectElement[] QuestgiverobjectElementArray) => new QuestgiverobjectUnion { QuestgiverobjectElementArray = QuestgiverobjectElementArray };
    }

    public partial struct QuestgiverUnion
    {
        public QuestgiverElement QuestgiverElement;
        public QuestgiverElement[] QuestgiverElementArray;

        public static implicit operator QuestgiverUnion(QuestgiverElement QuestgiverElement) => new QuestgiverUnion { QuestgiverElement = QuestgiverElement };
        public static implicit operator QuestgiverUnion(QuestgiverElement[] QuestgiverElementArray) => new QuestgiverUnion { QuestgiverElementArray = QuestgiverElementArray };
    }

    public partial struct TerritoryUnion
    {
        public PurpleTerritory PurpleTerritory;
        public TerritoryElement[] TerritoryElementArray;

        public static implicit operator TerritoryUnion(PurpleTerritory PurpleTerritory) => new TerritoryUnion { PurpleTerritory = PurpleTerritory };
        public static implicit operator TerritoryUnion(TerritoryElement[] TerritoryElementArray) => new TerritoryUnion { TerritoryElementArray = TerritoryElementArray };
    }

    public partial struct ConnectionUnion
    {
        public ConnectionConnection ConnectionConnection;
        public ConnectionConnection[] ConnectionConnectionArray;

        public static implicit operator ConnectionUnion(ConnectionConnection ConnectionConnection) => new ConnectionUnion { ConnectionConnection = ConnectionConnection };
        public static implicit operator ConnectionUnion(ConnectionConnection[] ConnectionConnectionArray) => new ConnectionUnion { ConnectionConnectionArray = ConnectionConnectionArray };
    }

    public partial struct TravelpointUnion
    {
        public PurpleTravelpoint PurpleTravelpoint;
        public TravelpointElement[] TravelpointElementArray;

        public static implicit operator TravelpointUnion(PurpleTravelpoint PurpleTravelpoint) => new TravelpointUnion { PurpleTravelpoint = PurpleTravelpoint };
        public static implicit operator TravelpointUnion(TravelpointElement[] TravelpointElementArray) => new TravelpointUnion { TravelpointElementArray = TravelpointElementArray };
    }

    public partial class WorldMapRoot
    {
        public static WorldMapRoot FromJson(string json) => JsonConvert.DeserializeObject<WorldMapRoot>(json, QuickType.ClusterInfoConverter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this WorldMapRoot self) => JsonConvert.SerializeObject(self, QuickType.ClusterInfoConverter.Settings);
    }

    internal static class ClusterInfoConverter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                MinimapHeightRangeConverter.Singleton,
                RareresourcedistributionConverter.Singleton,
                TimeregionConverter.Singleton,
                NameConverter.Singleton,
                RoadtypeConverter.Singleton,
                TargettypeConverter.Singleton,
                MarkerUnionConverter.Singleton,
                OutpostUnionConverter.Singleton,
                OutpostTypeConverter.Singleton,
                QuestgiverobjectUnionConverter.Singleton,
                QuestgiverUnionConverter.Singleton,
                TerritoryUnionConverter.Singleton,
                CastletypeConverter.Singleton,
                ResourcetypeConverter.Singleton,
                SizeConverter.Singleton,
                TerritorytypeConverter.Singleton,
                ConnectionTypeConverter.Singleton,
                TravelpointUnionConverter.Singleton,
                ConnectionUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PurpleParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly PurpleParseStringConverter Singleton = new PurpleParseStringConverter();
    }

    internal class FluffyParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(bool) || t == typeof(bool?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            bool b;
            if (Boolean.TryParse(value, out b))
            {
                return b;
            }
            throw new Exception("Cannot unmarshal type bool");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (bool)untypedValue;
            var boolString = value ? "true" : "false";
            serializer.Serialize(writer, boolString);
            return;
        }

        public static readonly FluffyParseStringConverter Singleton = new FluffyParseStringConverter();
    }

    internal class MinimapHeightRangeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MinimapHeightRange) || t == typeof(MinimapHeightRange?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "-12 8":
                    return MinimapHeightRange.The128;
                case "-16 0":
                    return MinimapHeightRange.The160;
                case "-16 16":
                    return MinimapHeightRange.The1616;
                case "-36 20":
                    return MinimapHeightRange.The3620;
                case "-8 12":
                    return MinimapHeightRange.The812;
                case "-8 24":
                    return MinimapHeightRange.The824;
                case "-8 8":
                    return MinimapHeightRange.The88;
                case "0 12":
                    return MinimapHeightRange.The012;
                case "0 16":
                    return MinimapHeightRange.The016;
                case "0 20":
                    return MinimapHeightRange.The020;
                case "0 28":
                    return MinimapHeightRange.The028;
                case "8 36":
                    return MinimapHeightRange.The836;
            }
            throw new Exception("Cannot unmarshal type MinimapHeightRange");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MinimapHeightRange)untypedValue;
            switch (value)
            {
                case MinimapHeightRange.The128:
                    serializer.Serialize(writer, "-12 8");
                    return;
                case MinimapHeightRange.The160:
                    serializer.Serialize(writer, "-16 0");
                    return;
                case MinimapHeightRange.The1616:
                    serializer.Serialize(writer, "-16 16");
                    return;
                case MinimapHeightRange.The3620:
                    serializer.Serialize(writer, "-36 20");
                    return;
                case MinimapHeightRange.The812:
                    serializer.Serialize(writer, "-8 12");
                    return;
                case MinimapHeightRange.The824:
                    serializer.Serialize(writer, "-8 24");
                    return;
                case MinimapHeightRange.The88:
                    serializer.Serialize(writer, "-8 8");
                    return;
                case MinimapHeightRange.The012:
                    serializer.Serialize(writer, "0 12");
                    return;
                case MinimapHeightRange.The016:
                    serializer.Serialize(writer, "0 16");
                    return;
                case MinimapHeightRange.The020:
                    serializer.Serialize(writer, "0 20");
                    return;
                case MinimapHeightRange.The028:
                    serializer.Serialize(writer, "0 28");
                    return;
                case MinimapHeightRange.The836:
                    serializer.Serialize(writer, "8 36");
                    return;
            }
            throw new Exception("Cannot marshal type MinimapHeightRange");
        }

        public static readonly MinimapHeightRangeConverter Singleton = new MinimapHeightRangeConverter();
    }

    internal class RareresourcedistributionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Rareresourcedistribution) || t == typeof(Rareresourcedistribution?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "DEFAULT":
                    return Rareresourcedistribution.Default;
                case "OUT_Q1":
                    return Rareresourcedistribution.OutQ1;
                case "OUT_Q2":
                    return Rareresourcedistribution.OutQ2;
                case "OUT_Q3":
                    return Rareresourcedistribution.OutQ3;
                case "OUT_Q4":
                    return Rareresourcedistribution.OutQ4;
                case "OUT_Q5":
                    return Rareresourcedistribution.OutQ5;
                case "OUT_Q6":
                    return Rareresourcedistribution.OutQ6;
                case "RED":
                    return Rareresourcedistribution.Red;
                case "RED2":
                    return Rareresourcedistribution.Red2;
                case "SAFE":
                    return Rareresourcedistribution.Safe;
                case "YELLOW":
                    return Rareresourcedistribution.Yellow;
            }
            throw new Exception("Cannot unmarshal type Rareresourcedistribution");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Rareresourcedistribution)untypedValue;
            switch (value)
            {
                case Rareresourcedistribution.Default:
                    serializer.Serialize(writer, "DEFAULT");
                    return;
                case Rareresourcedistribution.OutQ1:
                    serializer.Serialize(writer, "OUT_Q1");
                    return;
                case Rareresourcedistribution.OutQ2:
                    serializer.Serialize(writer, "OUT_Q2");
                    return;
                case Rareresourcedistribution.OutQ3:
                    serializer.Serialize(writer, "OUT_Q3");
                    return;
                case Rareresourcedistribution.OutQ4:
                    serializer.Serialize(writer, "OUT_Q4");
                    return;
                case Rareresourcedistribution.OutQ5:
                    serializer.Serialize(writer, "OUT_Q5");
                    return;
                case Rareresourcedistribution.OutQ6:
                    serializer.Serialize(writer, "OUT_Q6");
                    return;
                case Rareresourcedistribution.Red:
                    serializer.Serialize(writer, "RED");
                    return;
                case Rareresourcedistribution.Red2:
                    serializer.Serialize(writer, "RED2");
                    return;
                case Rareresourcedistribution.Safe:
                    serializer.Serialize(writer, "SAFE");
                    return;
                case Rareresourcedistribution.Yellow:
                    serializer.Serialize(writer, "YELLOW");
                    return;
            }
            throw new Exception("Cannot marshal type Rareresourcedistribution");
        }

        public static readonly RareresourcedistributionConverter Singleton = new RareresourcedistributionConverter();
    }

    internal class TimeregionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Timeregion) || t == typeof(Timeregion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AMERICA_EAST":
                    return Timeregion.AmericaEast;
                case "BR_00_00":
                    return Timeregion.Br00_00;
                case "EU":
                    return Timeregion.Eu;
                case "EU_20_00":
                    return Timeregion.Eu20_00;
                case "EU_21_00":
                    return Timeregion.Eu21_00;
                case "EU_RU_18_00":
                    return Timeregion.EuRu18_00;
                case "RU_15_00":
                    return Timeregion.Ru15_00;
                case "RU_16_00":
                    return Timeregion.Ru16_00;
                case "RU_ASIA_12_00":
                    return Timeregion.RuAsia12_00;
                case "US_01_00":
                    return Timeregion.Us01_00;
                case "US_03_00":
                    return Timeregion.Us03_00;
                case "US_04_00":
                    return Timeregion.Us04_00;
                case "US_05_00":
                    return Timeregion.Us05_00;
            }
            throw new Exception("Cannot unmarshal type Timeregion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Timeregion)untypedValue;
            switch (value)
            {
                case Timeregion.AmericaEast:
                    serializer.Serialize(writer, "AMERICA_EAST");
                    return;
                case Timeregion.Br00_00:
                    serializer.Serialize(writer, "BR_00_00");
                    return;
                case Timeregion.Eu:
                    serializer.Serialize(writer, "EU");
                    return;
                case Timeregion.Eu20_00:
                    serializer.Serialize(writer, "EU_20_00");
                    return;
                case Timeregion.Eu21_00:
                    serializer.Serialize(writer, "EU_21_00");
                    return;
                case Timeregion.EuRu18_00:
                    serializer.Serialize(writer, "EU_RU_18_00");
                    return;
                case Timeregion.Ru15_00:
                    serializer.Serialize(writer, "RU_15_00");
                    return;
                case Timeregion.Ru16_00:
                    serializer.Serialize(writer, "RU_16_00");
                    return;
                case Timeregion.RuAsia12_00:
                    serializer.Serialize(writer, "RU_ASIA_12_00");
                    return;
                case Timeregion.Us01_00:
                    serializer.Serialize(writer, "US_01_00");
                    return;
                case Timeregion.Us03_00:
                    serializer.Serialize(writer, "US_03_00");
                    return;
                case Timeregion.Us04_00:
                    serializer.Serialize(writer, "US_04_00");
                    return;
                case Timeregion.Us05_00:
                    serializer.Serialize(writer, "US_05_00");
                    return;
            }
            throw new Exception("Cannot marshal type Timeregion");
        }

        public static readonly TimeregionConverter Singleton = new TimeregionConverter();
    }

    internal class NameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Name) || t == typeof(Name?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "FIBER":
                    return Name.Fiber;
                case "HIDE":
                    return Name.Hide;
                case "ORE":
                    return Name.Ore;
                case "ROCK":
                    return Name.Rock;
                case "WOOD":
                    return Name.Wood;
            }
            throw new Exception("Cannot unmarshal type Name");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Name)untypedValue;
            switch (value)
            {
                case Name.Fiber:
                    serializer.Serialize(writer, "FIBER");
                    return;
                case Name.Hide:
                    serializer.Serialize(writer, "HIDE");
                    return;
                case Name.Ore:
                    serializer.Serialize(writer, "ORE");
                    return;
                case Name.Rock:
                    serializer.Serialize(writer, "ROCK");
                    return;
                case Name.Wood:
                    serializer.Serialize(writer, "WOOD");
                    return;
            }
            throw new Exception("Cannot marshal type Name");
        }

        public static readonly NameConverter Singleton = new NameConverter();
    }

    internal class RoadtypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Roadtype) || t == typeof(Roadtype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Primary":
                    return Roadtype.Primary;
                case "Secondary":
                    return Roadtype.Secondary;
            }
            throw new Exception("Cannot unmarshal type Roadtype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Roadtype)untypedValue;
            switch (value)
            {
                case Roadtype.Primary:
                    serializer.Serialize(writer, "Primary");
                    return;
                case Roadtype.Secondary:
                    serializer.Serialize(writer, "Secondary");
                    return;
            }
            throw new Exception("Cannot marshal type Roadtype");
        }

        public static readonly RoadtypeConverter Singleton = new RoadtypeConverter();
    }

    internal class TargettypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Targettype) || t == typeof(Targettype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Cluster":
                    return Targettype.Cluster;
                case "DungeonGroup":
                    return Targettype.DungeonGroup;
                case "DungeonRaid":
                    return Targettype.DungeonRaid;
                case "DungeonSandbox":
                    return Targettype.DungeonSandbox;
                case "DungeonSolo":
                    return Targettype.DungeonSolo;
                case "DungeonSpecial":
                    return Targettype.DungeonSpecial;
                case "DungeonStubSolo":
                    return Targettype.DungeonStubSolo;
            }
            throw new Exception("Cannot unmarshal type Targettype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Targettype)untypedValue;
            switch (value)
            {
                case Targettype.Cluster:
                    serializer.Serialize(writer, "Cluster");
                    return;
                case Targettype.DungeonGroup:
                    serializer.Serialize(writer, "DungeonGroup");
                    return;
                case Targettype.DungeonRaid:
                    serializer.Serialize(writer, "DungeonRaid");
                    return;
                case Targettype.DungeonSandbox:
                    serializer.Serialize(writer, "DungeonSandbox");
                    return;
                case Targettype.DungeonSolo:
                    serializer.Serialize(writer, "DungeonSolo");
                    return;
                case Targettype.DungeonSpecial:
                    serializer.Serialize(writer, "DungeonSpecial");
                    return;
                case Targettype.DungeonStubSolo:
                    serializer.Serialize(writer, "DungeonStubSolo");
                    return;
            }
            throw new Exception("Cannot marshal type Targettype");
        }

        public static readonly TargettypeConverter Singleton = new TargettypeConverter();
    }

    internal class MarkerUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MarkerUnion) || t == typeof(MarkerUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<MarkerElement>(reader);
                    return new MarkerUnion { MarkerElement = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<MarkerElement[]>(reader);
                    return new MarkerUnion { MarkerElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type MarkerUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (MarkerUnion)untypedValue;
            if (value.MarkerElementArray != null)
            {
                serializer.Serialize(writer, value.MarkerElementArray);
                return;
            }
            if (value.MarkerElement != null)
            {
                serializer.Serialize(writer, value.MarkerElement);
                return;
            }
            throw new Exception("Cannot marshal type MarkerUnion");
        }

        public static readonly MarkerUnionConverter Singleton = new MarkerUnionConverter();
    }

    internal class OutpostUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OutpostUnion) || t == typeof(OutpostUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<OutpostElement>(reader);
                    return new OutpostUnion { OutpostElement = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<OutpostElement[]>(reader);
                    return new OutpostUnion { OutpostElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type OutpostUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (OutpostUnion)untypedValue;
            if (value.OutpostElementArray != null)
            {
                serializer.Serialize(writer, value.OutpostElementArray);
                return;
            }
            if (value.OutpostElement != null)
            {
                serializer.Serialize(writer, value.OutpostElement);
                return;
            }
            throw new Exception("Cannot marshal type OutpostUnion");
        }

        public static readonly OutpostUnionConverter Singleton = new OutpostUnionConverter();
    }

    internal class OutpostTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OutpostType) || t == typeof(OutpostType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "OUTLAND_CHEST":
                    return OutpostType.OutlandChest;
                case "OUTLAND_COFFER_CASTLE":
                    return OutpostType.OutlandCofferCastle;
                case "OUTLAND_COFFER_CASTLEOUTPOST":
                    return OutpostType.OutlandCofferCastleoutpost;
                case "OUTLAND_LOCKER":
                    return OutpostType.OutlandLocker;
                case "OUTPOST_FOREST":
                    return OutpostType.OutpostForest;
                case "OUTPOST_HIGHLAND":
                    return OutpostType.OutpostHighland;
                case "OUTPOST_MOUNTAIN":
                    return OutpostType.OutpostMountain;
                case "OUTPOST_STEPPE":
                    return OutpostType.OutpostSteppe;
                case "OUTPOST_SWAMP":
                    return OutpostType.OutpostSwamp;
                case "ROYAL_LOCKER_T5":
                    return OutpostType.RoyalLockerT5;
                case "ROYAL_LOCKER_T7":
                    return OutpostType.RoyalLockerT7;
            }
            throw new Exception("Cannot unmarshal type OutpostType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OutpostType)untypedValue;
            switch (value)
            {
                case OutpostType.OutlandChest:
                    serializer.Serialize(writer, "OUTLAND_CHEST");
                    return;
                case OutpostType.OutlandCofferCastle:
                    serializer.Serialize(writer, "OUTLAND_COFFER_CASTLE");
                    return;
                case OutpostType.OutlandCofferCastleoutpost:
                    serializer.Serialize(writer, "OUTLAND_COFFER_CASTLEOUTPOST");
                    return;
                case OutpostType.OutlandLocker:
                    serializer.Serialize(writer, "OUTLAND_LOCKER");
                    return;
                case OutpostType.OutpostForest:
                    serializer.Serialize(writer, "OUTPOST_FOREST");
                    return;
                case OutpostType.OutpostHighland:
                    serializer.Serialize(writer, "OUTPOST_HIGHLAND");
                    return;
                case OutpostType.OutpostMountain:
                    serializer.Serialize(writer, "OUTPOST_MOUNTAIN");
                    return;
                case OutpostType.OutpostSteppe:
                    serializer.Serialize(writer, "OUTPOST_STEPPE");
                    return;
                case OutpostType.OutpostSwamp:
                    serializer.Serialize(writer, "OUTPOST_SWAMP");
                    return;
                case OutpostType.RoyalLockerT5:
                    serializer.Serialize(writer, "ROYAL_LOCKER_T5");
                    return;
                case OutpostType.RoyalLockerT7:
                    serializer.Serialize(writer, "ROYAL_LOCKER_T7");
                    return;
            }
            throw new Exception("Cannot marshal type OutpostType");
        }

        public static readonly OutpostTypeConverter Singleton = new OutpostTypeConverter();
    }

    internal class QuestgiverobjectUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(QuestgiverobjectUnion) || t == typeof(QuestgiverobjectUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<QuestgiverobjectElement>(reader);
                    return new QuestgiverobjectUnion { QuestgiverobjectElement = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<QuestgiverobjectElement[]>(reader);
                    return new QuestgiverobjectUnion { QuestgiverobjectElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type QuestgiverobjectUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (QuestgiverobjectUnion)untypedValue;
            if (value.QuestgiverobjectElementArray != null)
            {
                serializer.Serialize(writer, value.QuestgiverobjectElementArray);
                return;
            }
            if (value.QuestgiverobjectElement != null)
            {
                serializer.Serialize(writer, value.QuestgiverobjectElement);
                return;
            }
            throw new Exception("Cannot marshal type QuestgiverobjectUnion");
        }

        public static readonly QuestgiverobjectUnionConverter Singleton = new QuestgiverobjectUnionConverter();
    }

    internal class QuestgiverUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(QuestgiverUnion) || t == typeof(QuestgiverUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<QuestgiverElement>(reader);
                    return new QuestgiverUnion { QuestgiverElement = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<QuestgiverElement[]>(reader);
                    return new QuestgiverUnion { QuestgiverElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type QuestgiverUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (QuestgiverUnion)untypedValue;
            if (value.QuestgiverElementArray != null)
            {
                serializer.Serialize(writer, value.QuestgiverElementArray);
                return;
            }
            if (value.QuestgiverElement != null)
            {
                serializer.Serialize(writer, value.QuestgiverElement);
                return;
            }
            throw new Exception("Cannot marshal type QuestgiverUnion");
        }

        public static readonly QuestgiverUnionConverter Singleton = new QuestgiverUnionConverter();
    }

    internal class TerritoryUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TerritoryUnion) || t == typeof(TerritoryUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleTerritory>(reader);
                    return new TerritoryUnion { PurpleTerritory = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TerritoryElement[]>(reader);
                    return new TerritoryUnion { TerritoryElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TerritoryUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TerritoryUnion)untypedValue;
            if (value.TerritoryElementArray != null)
            {
                serializer.Serialize(writer, value.TerritoryElementArray);
                return;
            }
            if (value.PurpleTerritory != null)
            {
                serializer.Serialize(writer, value.PurpleTerritory);
                return;
            }
            throw new Exception("Cannot marshal type TerritoryUnion");
        }

        public static readonly TerritoryUnionConverter Singleton = new TerritoryUnionConverter();
    }

    internal class CastletypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Castletype) || t == typeof(Castletype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "MEDIUMCASTLE":
                    return Castletype.Mediumcastle;
                case "SMALLCASTLE":
                    return Castletype.Smallcastle;
            }
            throw new Exception("Cannot unmarshal type Castletype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Castletype)untypedValue;
            switch (value)
            {
                case Castletype.Mediumcastle:
                    serializer.Serialize(writer, "MEDIUMCASTLE");
                    return;
                case Castletype.Smallcastle:
                    serializer.Serialize(writer, "SMALLCASTLE");
                    return;
            }
            throw new Exception("Cannot marshal type Castletype");
        }

        public static readonly CastletypeConverter Singleton = new CastletypeConverter();
    }

    internal class ResourcetypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Resourcetype) || t == typeof(Resourcetype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Farm":
                    return Resourcetype.Farm;
                case "Resource":
                    return Resourcetype.Resource;
            }
            throw new Exception("Cannot unmarshal type Resourcetype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Resourcetype)untypedValue;
            switch (value)
            {
                case Resourcetype.Farm:
                    serializer.Serialize(writer, "Farm");
                    return;
                case Resourcetype.Resource:
                    serializer.Serialize(writer, "Resource");
                    return;
            }
            throw new Exception("Cannot marshal type Resourcetype");
        }

        public static readonly ResourcetypeConverter Singleton = new ResourcetypeConverter();
    }

    internal class SizeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Size) || t == typeof(Size?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "148 148":
                    return Size.The148148;
                case "150 150":
                    return Size.The150150;
                case "260 260":
                    return Size.The260260;
            }
            throw new Exception("Cannot unmarshal type Size");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Size)untypedValue;
            switch (value)
            {
                case Size.The148148:
                    serializer.Serialize(writer, "148 148");
                    return;
                case Size.The150150:
                    serializer.Serialize(writer, "150 150");
                    return;
                case Size.The260260:
                    serializer.Serialize(writer, "260 260");
                    return;
            }
            throw new Exception("Cannot marshal type Size");
        }

        public static readonly SizeConverter Singleton = new SizeConverter();
    }

    internal class TerritorytypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Territorytype) || t == typeof(Territorytype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CASTLE":
                    return Territorytype.Castle;
                case "SIEGECAMP":
                    return Territorytype.Siegecamp;
                case "WATCHTOWER":
                    return Territorytype.Watchtower;
            }
            throw new Exception("Cannot unmarshal type Territorytype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Territorytype)untypedValue;
            switch (value)
            {
                case Territorytype.Castle:
                    serializer.Serialize(writer, "CASTLE");
                    return;
                case Territorytype.Siegecamp:
                    serializer.Serialize(writer, "SIEGECAMP");
                    return;
                case Territorytype.Watchtower:
                    serializer.Serialize(writer, "WATCHTOWER");
                    return;
            }
            throw new Exception("Cannot marshal type Territorytype");
        }

        public static readonly TerritorytypeConverter Singleton = new TerritorytypeConverter();
    }

    internal class ConnectionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ConnectionType) || t == typeof(ConnectionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EAST":
                    return ConnectionType.East;
                case "NORTH":
                    return ConnectionType.North;
                case "SOUTH":
                    return ConnectionType.South;
                case "WEST":
                    return ConnectionType.West;
            }
            throw new Exception("Cannot unmarshal type ConnectionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ConnectionType)untypedValue;
            switch (value)
            {
                case ConnectionType.East:
                    serializer.Serialize(writer, "EAST");
                    return;
                case ConnectionType.North:
                    serializer.Serialize(writer, "NORTH");
                    return;
                case ConnectionType.South:
                    serializer.Serialize(writer, "SOUTH");
                    return;
                case ConnectionType.West:
                    serializer.Serialize(writer, "WEST");
                    return;
            }
            throw new Exception("Cannot marshal type ConnectionType");
        }

        public static readonly ConnectionTypeConverter Singleton = new ConnectionTypeConverter();
    }

    internal class TravelpointUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TravelpointUnion) || t == typeof(TravelpointUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleTravelpoint>(reader);
                    return new TravelpointUnion { PurpleTravelpoint = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TravelpointElement[]>(reader);
                    return new TravelpointUnion { TravelpointElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TravelpointUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TravelpointUnion)untypedValue;
            if (value.TravelpointElementArray != null)
            {
                serializer.Serialize(writer, value.TravelpointElementArray);
                return;
            }
            if (value.PurpleTravelpoint != null)
            {
                serializer.Serialize(writer, value.PurpleTravelpoint);
                return;
            }
            throw new Exception("Cannot marshal type TravelpointUnion");
        }

        public static readonly TravelpointUnionConverter Singleton = new TravelpointUnionConverter();
    }

    internal class ConnectionUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ConnectionUnion) || t == typeof(ConnectionUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ConnectionConnection>(reader);
                    return new ConnectionUnion { ConnectionConnection = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ConnectionConnection[]>(reader);
                    return new ConnectionUnion { ConnectionConnectionArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ConnectionUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ConnectionUnion)untypedValue;
            if (value.ConnectionConnectionArray != null)
            {
                serializer.Serialize(writer, value.ConnectionConnectionArray);
                return;
            }
            if (value.ConnectionConnection != null)
            {
                serializer.Serialize(writer, value.ConnectionConnection);
                return;
            }
            throw new Exception("Cannot marshal type ConnectionUnion");
        }

        public static readonly ConnectionUnionConverter Singleton = new ConnectionUnionConverter();
    }
}
